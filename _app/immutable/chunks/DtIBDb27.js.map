{"version":3,"file":"DtIBDb27.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/blocks/if.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/store.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/props.js","../../../../../../src/lib/paraglide/runtime.js"],"sourcesContent":["/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START, HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node, elseif?: [number,number]) => void, flag?: boolean) => void) => void} fn\n * @param {[number,number]} [elseif]\n * @returns {void}\n */\nexport function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {\n\tif (hydrating && root_index === 0) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {UNINITIALIZED | boolean | null} */\n\tvar condition = UNINITIALIZED;\n\n\tvar flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;\n\n\tvar has_branch = false;\n\n\tconst set_branch = (\n\t\t/** @type {(anchor: Node, elseif?: [number,number]) => void} */ fn,\n\t\tflag = true\n\t) => {\n\t\thas_branch = true;\n\t\tupdate_branch(flag, fn);\n\t};\n\n\tconst update_branch = (\n\t\t/** @type {boolean | null} */ new_condition,\n\t\t/** @type {null | ((anchor: Node, elseif?: [number,number]) => void)} */ fn\n\t) => {\n\t\tif (condition === (condition = new_condition)) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating && hydrate_index !== -1) {\n\t\t\tif (root_index === 0) {\n\t\t\t\tconst data = read_hydration_instruction(anchor);\n\n\t\t\t\tif (data === HYDRATION_START) {\n\t\t\t\t\thydrate_index = 0;\n\t\t\t\t} else if (data === HYDRATION_START_ELSE) {\n\t\t\t\t\thydrate_index = Infinity;\n\t\t\t\t} else {\n\t\t\t\t\thydrate_index = parseInt(data.substring(1));\n\t\t\t\t\tif (hydrate_index !== hydrate_index) {\n\t\t\t\t\t\t// if hydrate_index is NaN\n\t\t\t\t\t\t// we set an invalid index to force mismatch\n\t\t\t\t\t\thydrate_index = condition ? Infinity : -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst is_else = hydrate_index > root_index;\n\n\t\t\tif (!!condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t\thydrate_index = -1; // ignore hydration in next else if\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else if (fn) {\n\t\t\t\tconsequent_effect = branch(() => fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (fn) {\n\t\t\t\talternate_effect = branch(() => fn(anchor, [root_index + 1, hydrate_index]));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t};\n\n\tblock(() => {\n\t\thas_branch = false;\n\t\tfn(set_branch);\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(null, null);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { get as get_store } from '../../../store/shared/index.js';\nimport { define_property, noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\nlet IS_UNMOUNTED = Symbol();\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\t// if the component that setup this is already unmounted we don't want to register a subscription\n\tif (entry.store !== store && !(IS_UNMOUNTED in stores)) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\t// if the component that setup this stores is already unmounted the source will be out of sync\n\t// so we just use the `get` for the stores, less performant but it avoids to create a memory leak\n\t// and it will keep the value consistent\n\tif (store && IS_UNMOUNTED in stores) {\n\t\treturn get_store(store);\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {[StoreReferencesContainer, ()=>void]}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tfunction cleanup() {\n\t\tteardown(() => {\n\t\t\tfor (var store_name in stores) {\n\t\t\t\tconst ref = stores[store_name];\n\t\t\t\tref.unsubscribe();\n\t\t\t}\n\t\t\tdefine_property(stores, IS_UNMOUNTED, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true\n\t\t\t});\n\t\t});\n\t}\n\n\treturn [stores, cleanup];\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n","/** @import { Derived, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source, update } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport { get, captured_signals, untrack } from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { LEGACY_DERIVED_PROP, LEGACY_PROPS, STATE_SYMBOL } from '#client/constants';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\nimport { legacy_mode_flag } from '../../flags/index.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\t// To prevent a false positive `is_entry_props` in the `prop` function\n\t\tif (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (!p) continue;\n\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\n\t\t\tfor (const key of Object.getOwnPropertySymbols(p)) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @param {Derived} current_value\n * @returns {boolean}\n */\nfunction has_destroyed_component_ctx(current_value) {\n\treturn current_value.ctx?.d ?? false;\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\tvar is_store_sub = false;\n\tvar prop_value;\n\n\tif (bindable) {\n\t\t[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tprop_value = /** @type {V} */ (props[key]);\n\t}\n\n\t// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`\n\t// or `createClassComponent(Component, props)`\n\tvar is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;\n\n\tvar setter =\n\t\t(bindable &&\n\t\t\t(get_descriptor(props, key)?.set ??\n\t\t\t\t(is_entry_props && key in props && ((v) => (props[key] = v))))) ||\n\t\tundefined;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = (immutable ? derived : derived_safe_equal)(\n\t\t\t() => /** @type {V} */ (props[key])\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode â€” prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0 && runes) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode â€” prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly â€” the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = derived(() => {\n\t\tvar parent_value = getter();\n\t\tvar child_value = get(inner_current_value);\n\n\t\tif (from_child) {\n\t\t\tfrom_child = false;\n\t\t\twas_from_child = true;\n\t\t\treturn child_value;\n\t\t}\n\n\t\twas_from_child = false;\n\t\treturn (inner_current_value.v = parent_value);\n\t});\n\n\t// Ensure we eagerly capture the initial value if it's bindable\n\tif (bindable) {\n\t\tget(current_value);\n\t}\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t// legacy nonsense â€” need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (captured_signals !== null) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\n\t\t\t\tif (has_destroyed_component_ctx(current_value)) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tif (has_destroyed_component_ctx(current_value)) {\n\t\t\treturn current_value.v;\n\t\t}\n\n\t\treturn get(current_value);\n\t};\n}\n","// eslint-disable\n\n/** @type {any} */\nconst URLPattern = {}\n\n/**\n * The project's base locale.\n *\n * @example\n *   if (locale === baseLocale) {\n *     // do something\n *   }\n */\nexport const baseLocale = \"zh-cn\";\n/**\n * The project's locales that have been specified in the settings.\n *\n * @example\n *   if (locales.includes(userSelectedLocale) === false) {\n *     throw new Error('Locale is not available');\n *   }\n */\nexport const locales = /** @type {const} */ ([\"zh-cn\", \"en\"]);\n/** @type {string} */\nexport const cookieName = \"PARAGLIDE_LOCALE\";\n/** @type {number} */\nexport const cookieMaxAge = 34560000;\n/** @type {string} */\nexport const cookieDomain = \"\";\n/** @type {string} */\nexport const localStorageKey = \"PARAGLIDE_LOCALE\";\n/**\n * @type {Array<\"cookie\" | \"baseLocale\" | \"globalVariable\" | \"url\" | \"preferredLanguage\" | \"localStorage\">}\n */\nexport const strategy = [\n  \"cookie\",\n  \"preferredLanguage\",\n  \"baseLocale\"\n];\n/**\n * The used URL patterns.\n *\n * @type {Array<{ pattern: string, localized: Array<[Locale, string]> }> }\n */\nexport const urlPatterns = [\n  {\n    \"pattern\": \":protocol://:domain(.*)::port?/:path(.*)?\",\n    \"localized\": [\n      [\n        \"en\",\n        \":protocol://:domain(.*)::port?/en/:path(.*)?\"\n      ],\n      [\n        \"zh-cn\",\n        \":protocol://:domain(.*)::port?/:path(.*)?\"\n      ]\n    ]\n  }\n];\n/**\n * @typedef {{\n * \t\tgetStore(): {\n *   \t\tlocale?: Locale,\n * \t\t\torigin?: string,\n * \t\t\tmessageCalls?: Set<string>\n *   \t} | undefined,\n * \t\trun: (store: { locale?: Locale, origin?: string, messageCalls?: Set<string>},\n *    cb: any) => any\n * }} ParaglideAsyncLocalStorage\n */\n/**\n * Server side async local storage that is set by `serverMiddleware()`.\n *\n * The variable is used to retrieve the locale and origin in a server-side\n * rendering context without effecting other requests.\n *\n * @type {ParaglideAsyncLocalStorage | undefined}\n */\nexport let serverAsyncLocalStorage = undefined;\nexport const disableAsyncLocalStorage = false;\nexport const experimentalMiddlewareLocaleSplitting = false;\nexport const isServer = import.meta.env?.SSR ?? typeof window === 'undefined';\n/**\n * Sets the server side async local storage.\n *\n * The function is needed because the `runtime.js` file\n * must define the `serverAsyncLocalStorage` variable to\n * avoid a circular import between `runtime.js` and\n * `server.js` files.\n *\n * @param {ParaglideAsyncLocalStorage | undefined} value\n */\nexport function overwriteServerAsyncLocalStorage(value) {\n    serverAsyncLocalStorage = value;\n}\nconst TREE_SHAKE_COOKIE_STRATEGY_USED = true;\nconst TREE_SHAKE_URL_STRATEGY_USED = false;\nconst TREE_SHAKE_GLOBAL_VARIABLE_STRATEGY_USED = false;\nconst TREE_SHAKE_PREFERRED_LANGUAGE_STRATEGY_USED = true;\nconst TREE_SHAKE_DEFAULT_URL_PATTERN_USED = true;\nconst TREE_SHAKE_LOCAL_STORAGE_STRATEGY_USED = false;\n\nglobalThis.__paraglide = {}\n\n/**\n * This is a fallback to get started with a custom\n * strategy and avoid type errors.\n *\n * The implementation is overwritten\n * by \\`overwriteGetLocale()\\` and \\`defineSetLocale()\\`.\n *\n * @type {Locale|undefined}\n */\nlet _locale;\nlet localeInitiallySet = false;\n/**\n * Get the current locale.\n *\n * @example\n *   if (getLocale() === 'de') {\n *     console.log('Germany ðŸ‡©ðŸ‡ª');\n *   } else if (getLocale() === 'nl') {\n *     console.log('Netherlands ðŸ‡³ðŸ‡±');\n *   }\n *\n * @type {() => Locale}\n */\nexport let getLocale = () => {\n    /** @type {string | undefined} */\n    let locale;\n    // if running in a server-side rendering context\n    // retrieve the locale from the async local storage\n    if (serverAsyncLocalStorage) {\n        const locale = serverAsyncLocalStorage?.getStore()?.locale;\n        if (locale) {\n            return locale;\n        }\n    }\n    for (const strat of strategy) {\n        if (TREE_SHAKE_COOKIE_STRATEGY_USED && strat === \"cookie\") {\n            locale = extractLocaleFromCookie();\n        }\n        else if (strat === \"baseLocale\") {\n            locale = baseLocale;\n        }\n        else if (TREE_SHAKE_URL_STRATEGY_USED &&\n            strat === \"url\" &&\n            !isServer &&\n            typeof window !== \"undefined\") {\n            locale = extractLocaleFromUrl(window.location.href);\n        }\n        else if (TREE_SHAKE_GLOBAL_VARIABLE_STRATEGY_USED &&\n            strat === \"globalVariable\" &&\n            _locale !== undefined) {\n            locale = _locale;\n        }\n        else if (TREE_SHAKE_PREFERRED_LANGUAGE_STRATEGY_USED &&\n            strat === \"preferredLanguage\" &&\n            !isServer) {\n            locale = negotiatePreferredLanguageFromNavigator();\n        }\n        else if (TREE_SHAKE_LOCAL_STORAGE_STRATEGY_USED &&\n            strat === \"localStorage\" &&\n            !isServer) {\n            locale = localStorage.getItem(localStorageKey) ?? undefined;\n        }\n        // check if match, else continue loop\n        if (locale !== undefined) {\n            const asserted = assertIsLocale(locale);\n            if (!localeInitiallySet) {\n                _locale = asserted;\n                // https://github.com/opral/inlang-paraglide-js/issues/455\n                localeInitiallySet = true;\n                setLocale(asserted, { reload: false });\n            }\n            return asserted;\n        }\n    }\n    throw new Error(\"No locale found. Read the docs https://inlang.com/m/gerre34r/library-inlang-paraglideJs/errors#no-locale-found\");\n};\n/**\n * Negotiates a preferred language from navigator.languages.\n *\n * @returns {string|undefined} The negotiated preferred language.\n */\nfunction negotiatePreferredLanguageFromNavigator() {\n    if (!navigator?.languages?.length) {\n        return undefined;\n    }\n    const languages = navigator.languages.map((lang) => ({\n        fullTag: lang.toLowerCase(),\n        baseTag: lang.split(\"-\")[0]?.toLowerCase(),\n    }));\n    for (const lang of languages) {\n        if (isLocale(lang.fullTag)) {\n            return lang.fullTag;\n        }\n        else if (isLocale(lang.baseTag)) {\n            return lang.baseTag;\n        }\n    }\n    return undefined;\n}\n/**\n * Overwrite the \\`getLocale()\\` function.\n *\n * Use this function to overwrite how the locale is resolved. For example,\n * you can resolve the locale from the browser's preferred language,\n * a cookie, env variable, or a user's preference.\n *\n * @example\n *   overwriteGetLocale(() => {\n *     // resolve the locale from a cookie. fallback to the base locale.\n *     return Cookies.get('locale') ?? baseLocale\n *   }\n *\n * @type {(fn: () => Locale) => void}\n */\nexport const overwriteGetLocale = (fn) => {\n    getLocale = fn;\n};\n\n/**\n * Set the locale.\n *\n * Set locale reloads the site by default on the client. Reloading\n * can be disabled by passing \\`reload: false\\` as an option. If\n * reloading is disabled, you need to ensure that the UI is updated\n * to reflect the new locale.\n *\n * @example\n *   setLocale('en');\n *\n * @example\n *   setLocale('en', { reload: false });\n *\n * @type {(newLocale: Locale, options?: { reload?: boolean }) => void}\n */\nexport let setLocale = (newLocale, options) => {\n    const optionsWithDefaults = {\n        reload: true,\n        ...options,\n    };\n    // locale is already set\n    // https://github.com/opral/inlang-paraglide-js/issues/430\n    let currentLocale;\n    try {\n        currentLocale = getLocale();\n    }\n    catch {\n        // do nothing, no locale has been set yet.\n    }\n    /** @type {string | undefined} */\n    let newLocation = undefined;\n    for (const strat of strategy) {\n        if (TREE_SHAKE_GLOBAL_VARIABLE_STRATEGY_USED &&\n            strat === \"globalVariable\") {\n            // a default for a custom strategy to get started quickly\n            // is likely overwritten by `defineSetLocale()`\n            _locale = newLocale;\n        }\n        else if (TREE_SHAKE_COOKIE_STRATEGY_USED && strat === \"cookie\") {\n            if (isServer ||\n                typeof document === \"undefined\" ||\n                typeof window === \"undefined\") {\n                continue;\n            }\n            const domain = cookieDomain || window.location.hostname;\n            // set the cookie\n            document.cookie = `${cookieName}=${newLocale}; path=/; max-age=${cookieMaxAge}; domain=${domain}`;\n        }\n        else if (strat === \"baseLocale\") {\n            // nothing to be set here. baseLocale is only a fallback\n            continue;\n        }\n        else if (TREE_SHAKE_URL_STRATEGY_USED &&\n            strat === \"url\" &&\n            typeof window !== \"undefined\") {\n            // route to the new url\n            //\n            // this triggers a page reload but a user rarely\n            // switches locales, so this should be fine.\n            //\n            // if the behavior is not desired, the implementation\n            // can be overwritten by `defineSetLocale()` to avoid\n            // a full page reload.\n            newLocation = localizeUrl(window.location.href, {\n                locale: newLocale,\n            }).href;\n        }\n        else if (TREE_SHAKE_LOCAL_STORAGE_STRATEGY_USED &&\n            strat === \"localStorage\" &&\n            typeof window !== \"undefined\") {\n            // set the localStorage\n            localStorage.setItem(localStorageKey, newLocale);\n        }\n    }\n    if (!isServer &&\n        optionsWithDefaults.reload &&\n        window.location &&\n        newLocale !== currentLocale) {\n        if (newLocation) {\n            // reload the page by navigating to the new url\n            window.location.href = newLocation;\n        }\n        else {\n            // reload the page to reflect the new locale\n            window.location.reload();\n        }\n    }\n    return;\n};\n/**\n * Overwrite the \\`setLocale()\\` function.\n *\n * Use this function to overwrite how the locale is set. For example,\n * modify a cookie, env variable, or a user's preference.\n *\n * @example\n *   overwriteSetLocale((newLocale) => {\n *     // set the locale in a cookie\n *     return Cookies.set('locale', newLocale)\n *   });\n *\n * @param {(newLocale: Locale) => void} fn\n */\nexport const overwriteSetLocale = (fn) => {\n    setLocale = fn;\n};\n\n/**\n * The origin of the current URL.\n *\n * Defaults to \"http://y.com\" in non-browser environments. If this\n * behavior is not desired, the implementation can be overwritten\n * by `overwriteGetUrlOrigin()`.\n *\n * @type {() => string}\n */\nexport let getUrlOrigin = () => {\n    if (serverAsyncLocalStorage) {\n        return serverAsyncLocalStorage.getStore()?.origin ?? \"http://fallback.com\";\n    }\n    else if (typeof window !== \"undefined\") {\n        return window.location.origin;\n    }\n    return \"http://fallback.com\";\n};\n/**\n * Overwrite the getUrlOrigin function.\n *\n * Use this function in server environments to\n * define how the URL origin is resolved.\n *\n * @type {(fn: () => string) => void}\n */\nexport let overwriteGetUrlOrigin = (fn) => {\n    getUrlOrigin = fn;\n};\n\n/**\n * Check if something is an available locale.\n *\n * @example\n *   if (isLocale(params.locale)) {\n *     setLocale(params.locale);\n *   } else {\n *     setLocale('en');\n *   }\n *\n * @param {any} locale\n * @returns {locale is Locale}\n */\nexport function isLocale(locale) {\n    return !locale ? false : locales.includes(locale);\n}\n\n/**\n * Asserts that the input is a locale.\n *\n * @param {any} input - The input to check.\n * @returns {Locale} The input if it is a locale.\n * @throws {Error} If the input is not a locale.\n */\nexport function assertIsLocale(input) {\n    if (isLocale(input) === false) {\n        throw new Error(`Invalid locale: ${input}. Expected one of: ${locales.join(\", \")}`);\n    }\n    return input;\n}\n\n/**\n * Extracts a locale from a request.\n *\n * Use the function on the server to extract the locale\n * from a request.\n *\n * The function goes through the strategies in the order\n * they are defined. If a strategy returns an invalid locale,\n * it will fall back to the next strategy.\n *\n * @example\n *   const locale = extractLocaleFromRequest(request);\n *\n * @type {(request: Request) => Locale}\n */\nexport const extractLocaleFromRequest = (request) => {\n    /** @type {string|undefined} */\n    let locale;\n    for (const strat of strategy) {\n        if (TREE_SHAKE_COOKIE_STRATEGY_USED && strat === \"cookie\") {\n            locale = request.headers\n                .get(\"cookie\")\n                ?.split(\"; \")\n                .find((c) => c.startsWith(cookieName + \"=\"))\n                ?.split(\"=\")[1];\n        }\n        else if (TREE_SHAKE_URL_STRATEGY_USED && strat === \"url\") {\n            locale = extractLocaleFromUrl(request.url);\n        }\n        else if (TREE_SHAKE_PREFERRED_LANGUAGE_STRATEGY_USED &&\n            strat === \"preferredLanguage\") {\n            const acceptLanguageHeader = request.headers.get(\"accept-language\");\n            if (acceptLanguageHeader) {\n                locale = negotiatePreferredLanguageFromHeader(acceptLanguageHeader);\n            }\n        }\n        else if (strat === \"globalVariable\") {\n            locale = _locale;\n        }\n        else if (strat === \"baseLocale\") {\n            return baseLocale;\n        }\n        else if (strat === \"localStorage\") {\n            continue;\n        }\n        if (locale !== undefined) {\n            if (!isLocale(locale)) {\n                locale = undefined;\n            }\n            else {\n                return assertIsLocale(locale);\n            }\n        }\n    }\n    throw new Error(\"No locale found. There is an error in your strategy. Try adding 'baseLocale' as the very last strategy. Read more here https://inlang.com/m/gerre34r/library-inlang-paraglideJs/errors#no-locale-found\");\n};\n/**\n * Negotiates a preferred language from a header.\n *\n * @param {string} header - The header to negotiate from.\n * @returns {string|undefined} The negotiated preferred language.\n */\nfunction negotiatePreferredLanguageFromHeader(header) {\n    // Parse language preferences with their q-values and base language codes\n    const languages = header\n        .split(\",\")\n        .map((lang) => {\n        const [tag, q = \"1\"] = lang.trim().split(\";q=\");\n        // Get both the full tag and base language code\n        const baseTag = tag?.split(\"-\")[0]?.toLowerCase();\n        return {\n            fullTag: tag?.toLowerCase(),\n            baseTag,\n            q: Number(q),\n        };\n    })\n        .sort((a, b) => b.q - a.q);\n    for (const lang of languages) {\n        if (isLocale(lang.fullTag)) {\n            return lang.fullTag;\n        }\n        else if (isLocale(lang.baseTag)) {\n            return lang.baseTag;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Extracts a cookie from the document.\n *\n * Will return undefined if the docuement is not available or if the cookie is not set.\n * The `document` object is not available in server-side rendering, so this function should not be called in that context.\n *\n * @returns {string | undefined}\n */\nexport function extractLocaleFromCookie() {\n    if (typeof document === \"undefined\" || !document.cookie) {\n        return;\n    }\n    const match = document.cookie.match(new RegExp(`(^| )${cookieName}=([^;]+)`));\n    const locale = match?.[2];\n    if (isLocale(locale)) {\n        return locale;\n    }\n    return undefined;\n}\n\n/**\n * If extractLocaleFromUrl is called many times on the same page and the URL\n * hasn't changed, we don't need to recompute it every time which can get expensive.\n * We might use a LRU cache if needed, but for now storing only the last result is enough.\n * https://github.com/opral/monorepo/pull/3575#discussion_r2066731243\n */\n/** @type {string|undefined} */\nlet cachedUrl;\n/** @type {Locale|undefined} */\nlet cachedLocale;\n/**\n * Extracts the locale from a given URL using native URLPattern.\n *\n * @param {URL|string} url - The full URL from which to extract the locale.\n * @returns {Locale|undefined} The extracted locale, or undefined if no locale is found.\n */\nexport function extractLocaleFromUrl(url) {\n    const urlString = typeof url === \"string\" ? url : url.href;\n    if (cachedUrl === urlString) {\n        return cachedLocale;\n    }\n    let result;\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        result = defaultUrlPatternExtractLocale(url);\n    }\n    else {\n        const urlObj = typeof url === \"string\" ? new URL(url) : url;\n        // Iterate over URL patterns\n        for (const element of urlPatterns) {\n            for (const [locale, localizedPattern] of element.localized) {\n                const match = new URLPattern(localizedPattern, urlObj.href).exec(urlObj.href);\n                if (!match) {\n                    continue;\n                }\n                // Check if the locale is valid\n                if (assertIsLocale(locale)) {\n                    result = locale;\n                    break;\n                }\n            }\n            if (result)\n                break;\n        }\n    }\n    cachedUrl = urlString;\n    cachedLocale = result;\n    return result;\n}\n/**\n * https://github.com/opral/inlang-paraglide-js/issues/381\n *\n * @param {URL|string} url - The full URL from which to extract the locale.\n * @returns {Locale|undefined} The extracted locale, or undefined if no locale is found.\n */\nfunction defaultUrlPatternExtractLocale(url) {\n    const urlObj = new URL(url, \"http://dummy.com\");\n    const pathSegments = urlObj.pathname.split(\"/\").filter(Boolean);\n    if (pathSegments.length > 0) {\n        const potentialLocale = pathSegments[0];\n        if (isLocale(potentialLocale)) {\n            return potentialLocale;\n        }\n    }\n    // everything else has to be the base locale\n    return baseLocale;\n}\n\n/**\n * Lower-level URL localization function, primarily used in server contexts.\n *\n * This function is designed for server-side usage where you need precise control\n * over URL localization, such as in middleware or request handlers. It works with\n * URL objects and always returns absolute URLs.\n *\n * For client-side UI components, use `localizeHref()` instead, which provides\n * a more convenient API with relative paths and automatic locale detection.\n *\n * @example\n * ```typescript\n * // Server middleware example\n * app.use((req, res, next) => {\n *   const url = new URL(req.url, `${req.protocol}://${req.headers.host}`);\n *   const localized = localizeUrl(url, { locale: \"de\" });\n *\n *   if (localized.href !== url.href) {\n *     return res.redirect(localized.href);\n *   }\n *   next();\n * });\n * ```\n *\n * @example\n * ```typescript\n * // Using with URL patterns\n * const url = new URL(\"https://example.com/about\");\n * localizeUrl(url, { locale: \"de\" });\n * // => URL(\"https://example.com/de/about\")\n *\n * // Using with domain-based localization\n * const url = new URL(\"https://example.com/store\");\n * localizeUrl(url, { locale: \"de\" });\n * // => URL(\"https://de.example.com/store\")\n * ```\n *\n * @param {string | URL} url - The URL to localize. If string, must be absolute.\n * @param {Object} [options] - Options for localization\n * @param {string} [options.locale] - Target locale. If not provided, uses getLocale()\n * @returns {URL} The localized URL, always absolute\n */\nexport function localizeUrl(url, options) {\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        return localizeUrlDefaultPattern(url, options);\n    }\n    const targetLocale = options?.locale ?? getLocale();\n    const urlObj = typeof url === \"string\" ? new URL(url) : url;\n    // Iterate over URL patterns\n    for (const element of urlPatterns) {\n        // match localized patterns\n        for (const [, localizedPattern] of element.localized) {\n            const match = new URLPattern(localizedPattern, urlObj.href).exec(urlObj.href);\n            if (!match) {\n                continue;\n            }\n            const targetPattern = element.localized.find(([locale]) => locale === targetLocale)?.[1];\n            if (!targetPattern) {\n                continue;\n            }\n            const localizedUrl = fillPattern(targetPattern, aggregateGroups(match), urlObj.origin);\n            return fillMissingUrlParts(localizedUrl, match);\n        }\n        const unlocalizedMatch = new URLPattern(element.pattern, urlObj.href).exec(urlObj.href);\n        if (unlocalizedMatch) {\n            const targetPattern = element.localized.find(([locale]) => locale === targetLocale)?.[1];\n            if (targetPattern) {\n                const localizedUrl = fillPattern(targetPattern, aggregateGroups(unlocalizedMatch), urlObj.origin);\n                return fillMissingUrlParts(localizedUrl, unlocalizedMatch);\n            }\n        }\n    }\n    // If no match found, return the original URL\n    return urlObj;\n}\n/**\n * https://github.com/opral/inlang-paraglide-js/issues/381\n *\n * @param {string | URL} url\n * @param {Object} [options]\n * @param {string} [options.locale]\n * @returns {URL}\n */\nfunction localizeUrlDefaultPattern(url, options) {\n    const urlObj = typeof url === \"string\" ? new URL(url, getUrlOrigin()) : new URL(url);\n    const locale = options?.locale ?? getLocale();\n    const currentLocale = extractLocaleFromUrl(urlObj);\n    // If current locale matches target locale, no change needed\n    if (currentLocale === locale) {\n        return urlObj;\n    }\n    const pathSegments = urlObj.pathname.split(\"/\").filter(Boolean);\n    // If current path starts with a locale, remove it\n    if (pathSegments.length > 0 && isLocale(pathSegments[0])) {\n        pathSegments.shift();\n    }\n    // For base locale, don't add prefix\n    if (locale === baseLocale) {\n        urlObj.pathname = \"/\" + pathSegments.join(\"/\");\n    }\n    else {\n        // For other locales, add prefix\n        urlObj.pathname = \"/\" + locale + \"/\" + pathSegments.join(\"/\");\n    }\n    return urlObj;\n}\n/**\n * Low-level URL de-localization function, primarily used in server contexts.\n *\n * This function is designed for server-side usage where you need precise control\n * over URL de-localization, such as in middleware or request handlers. It works with\n * URL objects and always returns absolute URLs.\n *\n * For client-side UI components, use `deLocalizeHref()` instead, which provides\n * a more convenient API with relative paths.\n *\n * @example\n * ```typescript\n * // Server middleware example\n * app.use((req, res, next) => {\n *   const url = new URL(req.url, `${req.protocol}://${req.headers.host}`);\n *   const baseUrl = deLocalizeUrl(url);\n *\n *   // Store the base URL for later use\n *   req.baseUrl = baseUrl;\n *   next();\n * });\n * ```\n *\n * @example\n * ```typescript\n * // Using with URL patterns\n * const url = new URL(\"https://example.com/de/about\");\n * deLocalizeUrl(url); // => URL(\"https://example.com/about\")\n *\n * // Using with domain-based localization\n * const url = new URL(\"https://de.example.com/store\");\n * deLocalizeUrl(url); // => URL(\"https://example.com/store\")\n * ```\n *\n * @param {string | URL} url - The URL to de-localize. If string, must be absolute.\n * @returns {URL} The de-localized URL, always absolute\n */\nexport function deLocalizeUrl(url) {\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        return deLocalizeUrlDefaultPattern(url);\n    }\n    const urlObj = typeof url === \"string\" ? new URL(url) : url;\n    // Iterate over URL patterns\n    for (const element of urlPatterns) {\n        // Iterate over localized versions\n        for (const [, localizedPattern] of element.localized) {\n            const match = new URLPattern(localizedPattern, urlObj.href).exec(urlObj.href);\n            if (match) {\n                // Convert localized URL back to the base pattern\n                const groups = aggregateGroups(match);\n                const baseUrl = fillPattern(element.pattern, groups, urlObj.origin);\n                return fillMissingUrlParts(baseUrl, match);\n            }\n        }\n        // match unlocalized pattern\n        const unlocalizedMatch = new URLPattern(element.pattern, urlObj.href).exec(urlObj.href);\n        if (unlocalizedMatch) {\n            const baseUrl = fillPattern(element.pattern, aggregateGroups(unlocalizedMatch), urlObj.origin);\n            return fillMissingUrlParts(baseUrl, unlocalizedMatch);\n        }\n    }\n    // no match found return the original url\n    return urlObj;\n}\n/**\n * De-localizes a URL using the default pattern (/:locale/*)\n * @param {string|URL} url\n * @returns {URL}\n */\nfunction deLocalizeUrlDefaultPattern(url) {\n    const urlObj = typeof url === \"string\" ? new URL(url, getUrlOrigin()) : new URL(url);\n    const pathSegments = urlObj.pathname.split(\"/\").filter(Boolean);\n    // If first segment is a locale, remove it\n    if (pathSegments.length > 0 && isLocale(pathSegments[0])) {\n        urlObj.pathname = \"/\" + pathSegments.slice(1).join(\"/\");\n    }\n    return urlObj;\n}\n/**\n * Takes matches of implicit wildcards in the UrlPattern (when a part is missing\n * it is equal to '*') and adds them back to the result of fillPattern.\n *\n * At least protocol and hostname are required to create a valid URL inside fillPattern.\n *\n * @param {URL} url\n * @param {any} match\n * @returns {URL}\n */\nfunction fillMissingUrlParts(url, match) {\n    if (match.protocol.groups[\"0\"]) {\n        url.protocol = match.protocol.groups[\"0\"] ?? \"\";\n    }\n    if (match.hostname.groups[\"0\"]) {\n        url.hostname = match.hostname.groups[\"0\"] ?? \"\";\n    }\n    if (match.username.groups[\"0\"]) {\n        url.username = match.username.groups[\"0\"] ?? \"\";\n    }\n    if (match.password.groups[\"0\"]) {\n        url.password = match.password.groups[\"0\"] ?? \"\";\n    }\n    if (match.port.groups[\"0\"]) {\n        url.port = match.port.groups[\"0\"] ?? \"\";\n    }\n    if (match.pathname.groups[\"0\"]) {\n        url.pathname = match.pathname.groups[\"0\"] ?? \"\";\n    }\n    if (match.search.groups[\"0\"]) {\n        url.search = match.search.groups[\"0\"] ?? \"\";\n    }\n    if (match.hash.groups[\"0\"]) {\n        url.hash = match.hash.groups[\"0\"] ?? \"\";\n    }\n    return url;\n}\n/**\n * Fills a URL pattern with values for named groups, supporting all URLPattern-style modifiers.\n *\n * This function will eventually be replaced by https://github.com/whatwg/urlpattern/issues/73\n *\n * Matches:\n * - :name        -> Simple\n * - :name?       -> Optional\n * - :name+       -> One or more\n * - :name*       -> Zero or more\n * - :name(...)   -> Regex group\n * - {text}       -> Group delimiter\n * - {text}?      -> Optional group delimiter\n *\n * If the value is `null`, the segment is removed.\n *\n * @param {string} pattern - The URL pattern containing named groups.\n * @param {Record<string, string | null | undefined>} values - Object of values for named groups.\n * @param {string} origin - Base URL to use for URL construction.\n * @returns {URL} - The constructed URL with named groups filled.\n */\nfunction fillPattern(pattern, values, origin) {\n    // Pre-process the pattern to handle explicit port numbers\n    // This detects patterns like \"http://localhost:5173\" and protects the port number\n    // from being interpreted as a parameter\n    let processedPattern = pattern.replace(/(https?:\\/\\/[^:/]+):(\\d+)(\\/|$)/g, (_, protocol, port, slash) => {\n        // Replace \":5173\" with \"#PORT-5173#\" to protect it from parameter replacement\n        return `${protocol}#PORT-${port}#${slash}`;\n    });\n    // First, handle group delimiters with curly braces\n    let processedGroupDelimiters = processedPattern.replace(/\\{([^{}]*)\\}([?+*]?)/g, (_, content, modifier) => {\n        // For optional group delimiters\n        if (modifier === \"?\") {\n            // For optional groups, we'll include the content\n            return content;\n        }\n        // For non-optional group delimiters, always include the content\n        return content;\n    });\n    // Then handle named groups\n    let filled = processedGroupDelimiters.replace(/(\\/?):([a-zA-Z0-9_]+)(\\([^)]*\\))?([?+*]?)/g, (_, slash, name, __, modifier) => {\n        const value = values[name];\n        if (value === null) {\n            // If value is null, remove the entire segment including the preceding slash\n            return \"\";\n        }\n        if (modifier === \"?\") {\n            // Optional segment\n            return value !== undefined ? `${slash}${value}` : \"\";\n        }\n        if (modifier === \"+\" || modifier === \"*\") {\n            // Repeatable segments\n            if (value === undefined && modifier === \"+\") {\n                throw new Error(`Missing value for \"${name}\" (one or more required)`);\n            }\n            return value ? `${slash}${value}` : \"\";\n        }\n        // Simple named group (no modifier)\n        if (value === undefined) {\n            throw new Error(`Missing value for \"${name}\"`);\n        }\n        return `${slash}${value}`;\n    });\n    // Restore port numbers\n    filled = filled.replace(/#PORT-(\\d+)#/g, \":$1\");\n    return new URL(filled, origin);\n}\n/**\n * Aggregates named groups from various parts of the URLPattern match result.\n *\n *\n * @type {(match: any) => Record<string, string | null | undefined>}\n */\nexport function aggregateGroups(match) {\n    return {\n        ...match.hash.groups,\n        ...match.hostname.groups,\n        ...match.password.groups,\n        ...match.pathname.groups,\n        ...match.port.groups,\n        ...match.protocol.groups,\n        ...match.search.groups,\n        ...match.username.groups,\n    };\n}\n\n/**\n * High-level URL localization function optimized for client-side UI usage.\n *\n * This is a convenience wrapper around `localizeUrl()` that provides features\n * needed in UI:\n *\n * - Accepts relative paths (e.g., \"/about\")\n * - Returns relative paths when possible\n * - Automatically detects current locale if not specified\n * - Handles string input/output instead of URL objects\n *\n * @example\n * ```typescript\n * // In a React/Vue/Svelte component\n * const NavLink = ({ href }) => {\n *   // Automatically uses current locale, keeps path relative\n *   return <a href={localizeHref(href)}>...</a>;\n * };\n *\n * // Examples:\n * localizeHref(\"/about\")\n * // => \"/de/about\" (if current locale is \"de\")\n * localizeHref(\"/store\", { locale: \"fr\" })\n * // => \"/fr/store\" (explicit locale)\n *\n * // Cross-origin links remain absolute\n * localizeHref(\"https://other-site.com/about\")\n * // => \"https://other-site.com/de/about\"\n * ```\n *\n * For server-side URL localization (e.g., in middleware), use `localizeUrl()`\n * which provides more precise control over URL handling.\n *\n * @param {string} href - The href to localize (can be relative or absolute)\n * @param {Object} [options] - Options for localization\n * @param {string} [options.locale] - Target locale. If not provided, uses `getLocale()`\n * @returns {string} The localized href, relative if input was relative\n */\nexport function localizeHref(href, options) {\n    const currentLocale = getLocale();\n    const locale = options?.locale ?? currentLocale;\n    const url = new URL(href, getUrlOrigin());\n    const localized = localizeUrl(url, { locale });\n    // if the origin is identical and the href is relative,\n    // return the relative path\n    if (href.startsWith(\"/\") && url.origin === localized.origin) {\n        // check for cross origin localization in which case an absolute URL must be returned.\n        if (locale !== currentLocale) {\n            const localizedCurrentLocale = localizeUrl(url, {\n                locale: currentLocale,\n            });\n            if (localizedCurrentLocale.origin !== localized.origin) {\n                return localized.href;\n            }\n        }\n        return localized.pathname + localized.search + localized.hash;\n    }\n    return localized.href;\n}\n/**\n * High-level URL de-localization function optimized for client-side UI usage.\n *\n * This is a convenience wrapper around `deLocalizeUrl()` that provides features\n * needed in the UI:\n *\n * - Accepts relative paths (e.g., \"/de/about\")\n * - Returns relative paths when possible\n * - Handles string input/output instead of URL objects\n *\n * @example\n * ```typescript\n * // In a React/Vue/Svelte component\n * const LocaleSwitcher = ({ href }) => {\n *   // Remove locale prefix before switching\n *   const baseHref = deLocalizeHref(href);\n *   return locales.map(locale =>\n *     <a href={localizeHref(baseHref, { locale })}>\n *       Switch to {locale}\n *     </a>\n *   );\n * };\n *\n * // Examples:\n * deLocalizeHref(\"/de/about\")  // => \"/about\"\n * deLocalizeHref(\"/fr/store\")  // => \"/store\"\n *\n * // Cross-origin links remain absolute\n * deLocalizeHref(\"https://example.com/de/about\")\n * // => \"https://example.com/about\"\n * ```\n *\n * For server-side URL de-localization (e.g., in middleware), use `deLocalizeUrl()`\n * which provides more precise control over URL handling.\n *\n * @param {string} href - The href to de-localize (can be relative or absolute)\n * @returns {string} The de-localized href, relative if input was relative\n * @see deLocalizeUrl - For low-level URL de-localization in server contexts\n */\nexport function deLocalizeHref(href) {\n    const url = new URL(href, getUrlOrigin());\n    const deLocalized = deLocalizeUrl(url);\n    // If the origin is identical and the href is relative,\n    // return the relative path instead of the full URL.\n    if (href.startsWith(\"/\") && url.origin === deLocalized.origin) {\n        return deLocalized.pathname + deLocalized.search + deLocalized.hash;\n    }\n    return deLocalized.href;\n}\n\n/**\n * @param {string} safeModuleId\n * @param {Locale} locale\n */\nexport function trackMessageCall(safeModuleId, locale) {\n    if (isServer === false)\n        return;\n    const store = serverAsyncLocalStorage?.getStore();\n    if (store) {\n        store.messageCalls?.add(`${safeModuleId}:${locale}`);\n    }\n}\n\n/**\n * Generates a list of localized URLs for all provided URLs.\n *\n * This is useful for SSG (Static Site Generation) and sitemap generation.\n * NextJS and other frameworks use this function for SSG.\n *\n * @example\n * ```typescript\n * const urls = generateStaticLocalizedUrls([\n *   \"https://example.com/about\",\n *   \"https://example.com/blog\",\n * ]);\n * urls[0].href // => \"https://example.com/about\"\n * urls[1].href // => \"https://example.com/blog\"\n * urls[2].href // => \"https://example.com/de/about\"\n * urls[3].href // => \"https://example.com/de/blog\"\n * ...\n * ```\n *\n * @param {(string | URL)[]} urls - List of URLs to generate localized versions for. Can be absolute URLs or paths.\n * @returns {URL[]} List of localized URLs as URL objects\n */\nexport function generateStaticLocalizedUrls(urls) {\n    const localizedUrls = new Set();\n    // For default URL pattern, we can optimize the generation\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        for (const urlInput of urls) {\n            const url = urlInput instanceof URL\n                ? urlInput\n                : new URL(urlInput, \"http://localhost\");\n            // Base locale doesn't get a prefix\n            localizedUrls.add(url);\n            // Other locales get their code as prefix\n            for (const locale of locales) {\n                if (locale !== baseLocale) {\n                    const localizedPath = `/${locale}${url.pathname}${url.search}${url.hash}`;\n                    const localizedUrl = new URL(localizedPath, url.origin);\n                    localizedUrls.add(localizedUrl);\n                }\n            }\n        }\n        return Array.from(localizedUrls);\n    }\n    // For custom URL patterns, we need to use localizeUrl for each URL and locale\n    for (const urlInput of urls) {\n        const url = urlInput instanceof URL\n            ? urlInput\n            : new URL(urlInput, \"http://localhost\");\n        // Try each URL pattern to find one that matches\n        let patternFound = false;\n        for (const pattern of urlPatterns) {\n            try {\n                // Try to match the unlocalized pattern\n                const unlocalizedMatch = new URLPattern(pattern.pattern, url.href).exec(url.href);\n                if (!unlocalizedMatch)\n                    continue;\n                patternFound = true;\n                // Track unique localized URLs to avoid duplicates when patterns are the same\n                const seenUrls = new Set();\n                // Generate localized URL for each locale\n                for (const [locale] of pattern.localized) {\n                    try {\n                        const localizedUrl = localizeUrl(url, { locale });\n                        const urlString = localizedUrl.href;\n                        // Only add if we haven't seen this exact URL before\n                        if (!seenUrls.has(urlString)) {\n                            seenUrls.add(urlString);\n                            localizedUrls.add(localizedUrl);\n                        }\n                    }\n                    catch {\n                        // Skip if localization fails for this locale\n                        continue;\n                    }\n                }\n                break;\n            }\n            catch {\n                // Skip if pattern matching fails\n                continue;\n            }\n        }\n        // If no pattern matched, use the URL as is\n        if (!patternFound) {\n            localizedUrls.add(url);\n        }\n    }\n    return Array.from(localizedUrls);\n}\n\n// ------ TYPES ------\n\n/**\n * A locale that is available in the project.\n *\n * @example\n *   setLocale(request.locale as Locale)\n *\n * @typedef {(typeof locales)[number]} Locale\n */\n\n"],"names":["if_block","node","fn","root_index","hydrate_index","hydrating","hydrate_next","anchor","consequent_effect","alternate_effect","condition","UNINITIALIZED","flags","EFFECT_TRANSPARENT","has_branch","set_branch","flag","update_branch","new_condition","mismatch","data","read_hydration_instruction","HYDRATION_START","HYDRATION_START_ELSE","is_else","remove_nodes","set_hydrate_node","set_hydrating","resume_effect","branch","pause_effect","block","hydrate_node","is_store_binding","capture_store_binding","previous_is_store_binding","rest_props_handler","target","key","rest_props","props","exclude","name","has_destroyed_component_ctx","current_value","_a","prop","fallback","immutable","PROPS_IS_IMMUTABLE","runes","legacy_mode_flag","PROPS_IS_RUNES","bindable","PROPS_IS_BINDABLE","lazy","PROPS_IS_LAZY_INITIAL","is_store_sub","prop_value","is_entry_props","STATE_SYMBOL","LEGACY_PROPS","setter","get_descriptor","v","fallback_value","fallback_dirty","fallback_used","get_fallback","untrack","e.props_invalid_value","getter","value","derived_getter","derived","derived_safe_equal","LEGACY_DERIVED_PROP","get","PROPS_IS_UPDATED","legacy_parent","mutation","from_child","inner_current_value","mutable_source","parent_value","child_value","safe_equals","new_value","proxy","set","baseLocale","locales","cookieName","cookieMaxAge","strategy","localeInitiallySet","getLocale","locale","strat","extractLocaleFromCookie","negotiatePreferredLanguageFromNavigator","asserted","assertIsLocale","setLocale","languages","lang","isLocale","newLocale","options","optionsWithDefaults","currentLocale","domain","getUrlOrigin","input","match","deLocalizeUrl","url","deLocalizeUrlDefaultPattern","urlObj","pathSegments"],"mappings":"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","x_google_ignoreList":[0,1,2]}