{"version":3,"file":"D2JLwdaO.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/blocks/if.js","../../../../../../node_modules/svelte/src/internal/client/dom/elements/bindings/this.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/store.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/props.js","../../../../../../src/lib/paraglide/runtime.js"],"sourcesContent":["/** @import { TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport {\n\thydrate_next,\n\thydrating,\n\tread_hydration_instruction,\n\tskip_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block } from '../../reactivity/effects.js';\nimport { BranchManager } from './branches.js';\nimport { HYDRATION_START, HYDRATION_START_ELSE } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node) => void, key?: number | false) => void) => void} fn\n * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'\n * @returns {void}\n */\nexport function if_block(node, fn, elseif = false) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar branches = new BranchManager(node);\n\tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n\n\t/**\n\t * @param {number | false} key\n\t * @param {null | ((anchor: Node) => void)} fn\n\t */\n\tfunction update_branch(key, fn) {\n\t\tif (hydrating) {\n\t\t\tconst data = read_hydration_instruction(node);\n\n\t\t\t/**\n\t\t\t * @type {number | false}\n\t\t\t * \"[\" = branch 0, \"[1\" = branch 1, \"[2\" = branch 2, ..., \"[!\" = else (false)\n\t\t\t */\n\t\t\tvar hydrated_key;\n\n\t\t\tif (data === HYDRATION_START) {\n\t\t\t\thydrated_key = 0;\n\t\t\t} else if (data === HYDRATION_START_ELSE) {\n\t\t\t\thydrated_key = false;\n\t\t\t} else {\n\t\t\t\thydrated_key = parseInt(data.substring(1)); // \"[1\", \"[2\", etc.\n\t\t\t}\n\n\t\t\tif (key !== hydrated_key) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tvar anchor = skip_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tbranches.anchor = anchor;\n\n\t\t\t\tset_hydrating(false);\n\t\t\t\tbranches.ensure(key, fn);\n\t\t\t\tset_hydrating(true);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tbranches.ensure(key, fn);\n\t}\n\n\tblock(() => {\n\t\tvar has_branch = false;\n\n\t\tfn((fn, key = 0) => {\n\t\t\thas_branch = true;\n\t\t\tupdate_branch(key, fn);\n\t\t});\n\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(false, null);\n\t\t}\n\t}, flags);\n}\n","import { STATE_SYMBOL } from '#client/constants';\nimport { effect, render_effect } from '../../../reactivity/effects.js';\nimport { untrack } from '../../../runtime.js';\nimport { queue_micro_task } from '../../task.js';\n\n/**\n * @param {any} bound_value\n * @param {Element} element_or_component\n * @returns {boolean}\n */\nfunction is_bound_this(bound_value, element_or_component) {\n\treturn (\n\t\tbound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component\n\t);\n}\n\n/**\n * @param {any} element_or_component\n * @param {(value: unknown, ...parts: unknown[]) => void} update\n * @param {(...parts: unknown[]) => unknown} get_value\n * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,\n * \t\t\t\t\t\t\t\t\t\treturns all the parts of the each block context that are used in the expression\n * @returns {void}\n */\nexport function bind_this(element_or_component = {}, update, get_value, get_parts) {\n\teffect(() => {\n\t\t/** @type {unknown[]} */\n\t\tvar old_parts;\n\n\t\t/** @type {unknown[]} */\n\t\tvar parts;\n\n\t\trender_effect(() => {\n\t\t\told_parts = parts;\n\t\t\t// We only track changes to the parts, not the value itself to avoid unnecessary reruns.\n\t\t\tparts = get_parts?.() || [];\n\n\t\t\tuntrack(() => {\n\t\t\t\tif (element_or_component !== get_value(...parts)) {\n\t\t\t\t\tupdate(element_or_component, ...parts);\n\t\t\t\t\t// If this is an effect rerun (cause: each block context changes), then nullify the binding at\n\t\t\t\t\t// the previous position if it isn't already taken over by a different effect.\n\t\t\t\t\tif (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {\n\t\t\t\t\t\tupdate(null, ...old_parts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn () => {\n\t\t\t// We cannot use effects in the teardown phase, we we use a microtask instead.\n\t\t\tqueue_micro_task(() => {\n\t\t\t\tif (parts && is_bound_this(get_value(...parts), element_or_component)) {\n\t\t\t\t\tupdate(null, ...parts);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t});\n\n\treturn element_or_component;\n}\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { get as get_store } from '../../../store/shared/index.js';\nimport { define_property, noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\nimport { DEV } from 'esm-env';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\nlet IS_UNMOUNTED = Symbol();\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\tif (DEV) {\n\t\tentry.source.label = store_name;\n\t}\n\n\t// if the component that setup this is already unmounted we don't want to register a subscription\n\tif (entry.store !== store && !(IS_UNMOUNTED in stores)) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\t// if the component that setup this stores is already unmounted the source will be out of sync\n\t// so we just use the `get` for the stores, less performant but it avoids to create a memory leak\n\t// and it will keep the value consistent\n\tif (store && IS_UNMOUNTED in stores) {\n\t\treturn get_store(store);\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {[StoreReferencesContainer, ()=>void]}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tfunction cleanup() {\n\t\tteardown(() => {\n\t\t\tfor (var store_name in stores) {\n\t\t\t\tconst ref = stores[store_name];\n\t\t\t\tref.unsubscribe();\n\t\t\t}\n\t\t\tdefine_property(stores, IS_UNMOUNTED, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true\n\t\t\t});\n\t\t});\n\t}\n\n\treturn [stores, cleanup];\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n","/** @import { Effect, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { set, source, update } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport {\n\tactive_effect,\n\tget,\n\tis_destroying_effect,\n\tset_active_effect,\n\tuntrack\n} from '../runtime.js';\nimport * as e from '../errors.js';\nimport { DESTROYED, LEGACY_PROPS, STATE_SYMBOL } from '#client/constants';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\nimport { legacy_mode_flag } from '../../flags/index.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number>, parent_effect: Effect }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\tvar previous_effect = active_effect;\n\n\t\t\ttry {\n\t\t\t\tset_active_effect(target.parent_effect);\n\n\t\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\t\ttarget.special[key] = prop(\n\t\t\t\t\t{\n\t\t\t\t\t\tget [key]() {\n\t\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {string} */ (key),\n\t\t\t\t\tPROPS_IS_UPDATED\n\t\t\t\t);\n\t\t\t} finally {\n\t\t\t\tset_active_effect(previous_effect);\n\t\t\t}\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy(\n\t\t{\n\t\t\tprops,\n\t\t\texclude,\n\t\t\tspecial: {},\n\t\t\tversion: source(0),\n\t\t\t// TODO this is only necessary because we need to track component\n\t\t\t// destruction inside `prop`, because of `bind:this`, but it\n\t\t\t// seems likely that we can simplify `bind:this` instead\n\t\t\tparent_effect: /** @type {Effect} */ (active_effect)\n\t\t},\n\t\tlegacy_rest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @type {ProxyHandler<{ props: Array<Record<string | symbol, unknown> | (() => Record<string | symbol, unknown>)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\t// To prevent a false positive `is_entry_props` in the `prop` function\n\t\tif (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (!p) continue;\n\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\n\t\t\tfor (const key of Object.getOwnPropertySymbols(p)) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\n\tvar get_fallback = () => {\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\n\t\t\tfallback_value = lazy\n\t\t\t\t? untrack(/** @type {() => V} */ (fallback))\n\t\t\t\t: /** @type {V} */ (fallback);\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\t/** @type {((v: V) => void) | undefined} */\n\tvar setter;\n\n\tif (bindable) {\n\t\t// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`\n\t\t// or `createClassComponent(Component, props)`\n\t\tvar is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;\n\n\t\tsetter =\n\t\t\tget_descriptor(props, key)?.set ??\n\t\t\t(is_entry_props && key in props ? (v) => (props[key] = v) : undefined);\n\t}\n\n\tvar initial_value;\n\tvar is_store_sub = false;\n\n\tif (bindable) {\n\t\t[initial_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tinitial_value = /** @type {V} */ (props[key]);\n\t}\n\n\tif (initial_value === undefined && fallback !== undefined) {\n\t\tinitial_value = get_fallback();\n\n\t\tif (setter) {\n\t\t\tif (runes) e.props_invalid_value(key);\n\t\t\tsetter(initial_value);\n\t\t}\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\n\t\t\tif (value !== undefined) {\n\t\t\t\t// in legacy mode, we don't revert to the fallback value\n\t\t\t\t// if the prop goes from defined to undefined. The easiest\n\t\t\t\t// way to model this is to make the fallback undefined\n\t\t\t\t// as soon as the prop has a value\n\t\t\t\tfallback_value = /** @type {V} */ (undefined);\n\t\t\t}\n\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// prop is never written to â€” we only need a getter\n\tif (runes && (flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// prop is written to, but the parent component had `bind:foo` which\n\t// means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn /** @type {() => V} */ (\n\t\t\tfunction (/** @type {V} */ value, /** @type {boolean} */ mutation) {\n\t\t\t\tif (arguments.length > 0) {\n\t\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t);\n\t}\n\n\t// Either prop is written to, but there's no binding, which means we\n\t// create a derived that we can write to locally.\n\t// Or we are in legacy mode where we always create a derived to replicate that\n\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\tvar overridden = false;\n\n\tvar d = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {\n\t\toverridden = false;\n\t\treturn getter();\n\t});\n\n\tif (DEV) {\n\t\td.label = key;\n\t}\n\n\t// Capture the initial value if it's bindable\n\tif (bindable) get(d);\n\n\tvar parent_effect = /** @type {Effect} */ (active_effect);\n\n\treturn /** @type {() => V} */ (\n\t\tfunction (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\tconst new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;\n\n\t\t\t\tset(d, new_value);\n\t\t\t\toverridden = true;\n\n\t\t\t\tif (fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\t// special case â€” avoid recalculating the derived if we're in a\n\t\t\t// teardown function and the prop was overridden locally, or the\n\t\t\t// component was already destroyed (this latter part is necessary\n\t\t\t// because `bind:this` can read props after the component has\n\t\t\t// been destroyed. TODO simplify `bind:this`\n\t\t\tif ((is_destroying_effect && overridden) || (parent_effect.f & DESTROYED) !== 0) {\n\t\t\t\treturn d.v;\n\t\t\t}\n\n\t\t\treturn get(d);\n\t\t}\n\t);\n}\n","// eslint-disable\n\n/** @type {any} */\nconst URLPattern = {}\n\n/**\n * The project's base locale.\n *\n * @example\n *   if (locale === baseLocale) {\n *     // do something\n *   }\n */\nexport const baseLocale = \"zh-cn\";\n/**\n * The project's locales that have been specified in the settings.\n *\n * @example\n *   if (locales.includes(userSelectedLocale) === false) {\n *     throw new Error('Locale is not available');\n *   }\n */\nexport const locales = /** @type {const} */ ([\"zh-cn\", \"en\"]);\n/** @type {string} */\nexport const cookieName = \"PARAGLIDE_LOCALE\";\n/** @type {number} */\nexport const cookieMaxAge = 34560000;\n/** @type {string} */\nexport const cookieDomain = \"\";\n/** @type {string} */\nexport const localStorageKey = \"PARAGLIDE_LOCALE\";\n/**\n * @type {Array<\"cookie\" | \"baseLocale\" | \"globalVariable\" | \"url\" | \"preferredLanguage\" | \"localStorage\">}\n */\nexport const strategy = [\n  \"cookie\",\n  \"preferredLanguage\",\n  \"baseLocale\"\n];\n/**\n * The used URL patterns.\n *\n * @type {Array<{ pattern: string, localized: Array<[Locale, string]> }> }\n */\nexport const urlPatterns = [\n  {\n    \"pattern\": \":protocol://:domain(.*)::port?/:path(.*)?\",\n    \"localized\": [\n      [\n        \"en\",\n        \":protocol://:domain(.*)::port?/en/:path(.*)?\"\n      ],\n      [\n        \"zh-cn\",\n        \":protocol://:domain(.*)::port?/:path(.*)?\"\n      ]\n    ]\n  }\n];\n/**\n * @typedef {{\n * \t\tgetStore(): {\n *   \t\tlocale?: Locale,\n * \t\t\torigin?: string,\n * \t\t\tmessageCalls?: Set<string>\n *   \t} | undefined,\n * \t\trun: (store: { locale?: Locale, origin?: string, messageCalls?: Set<string>},\n *    cb: any) => any\n * }} ParaglideAsyncLocalStorage\n */\n/**\n * Server side async local storage that is set by `serverMiddleware()`.\n *\n * The variable is used to retrieve the locale and origin in a server-side\n * rendering context without effecting other requests.\n *\n * @type {ParaglideAsyncLocalStorage | undefined}\n */\nexport let serverAsyncLocalStorage = undefined;\nexport const disableAsyncLocalStorage = false;\nexport const experimentalMiddlewareLocaleSplitting = false;\nexport const isServer = import.meta.env?.SSR ?? typeof window === 'undefined';\n/**\n * Sets the server side async local storage.\n *\n * The function is needed because the `runtime.js` file\n * must define the `serverAsyncLocalStorage` variable to\n * avoid a circular import between `runtime.js` and\n * `server.js` files.\n *\n * @param {ParaglideAsyncLocalStorage | undefined} value\n */\nexport function overwriteServerAsyncLocalStorage(value) {\n    serverAsyncLocalStorage = value;\n}\nconst TREE_SHAKE_COOKIE_STRATEGY_USED = true;\nconst TREE_SHAKE_URL_STRATEGY_USED = false;\nconst TREE_SHAKE_GLOBAL_VARIABLE_STRATEGY_USED = false;\nconst TREE_SHAKE_PREFERRED_LANGUAGE_STRATEGY_USED = true;\nconst TREE_SHAKE_DEFAULT_URL_PATTERN_USED = true;\nconst TREE_SHAKE_LOCAL_STORAGE_STRATEGY_USED = false;\n\nglobalThis.__paraglide = {}\n\n/**\n * This is a fallback to get started with a custom\n * strategy and avoid type errors.\n *\n * The implementation is overwritten\n * by \\`overwriteGetLocale()\\` and \\`defineSetLocale()\\`.\n *\n * @type {Locale|undefined}\n */\nlet _locale;\nlet localeInitiallySet = false;\n/**\n * Get the current locale.\n *\n * @example\n *   if (getLocale() === 'de') {\n *     console.log('Germany ðŸ‡©ðŸ‡ª');\n *   } else if (getLocale() === 'nl') {\n *     console.log('Netherlands ðŸ‡³ðŸ‡±');\n *   }\n *\n * @type {() => Locale}\n */\nexport let getLocale = () => {\n    /** @type {string | undefined} */\n    let locale;\n    // if running in a server-side rendering context\n    // retrieve the locale from the async local storage\n    if (serverAsyncLocalStorage) {\n        const locale = serverAsyncLocalStorage?.getStore()?.locale;\n        if (locale) {\n            return locale;\n        }\n    }\n    for (const strat of strategy) {\n        if (TREE_SHAKE_COOKIE_STRATEGY_USED && strat === \"cookie\") {\n            locale = extractLocaleFromCookie();\n        }\n        else if (strat === \"baseLocale\") {\n            locale = baseLocale;\n        }\n        else if (TREE_SHAKE_URL_STRATEGY_USED &&\n            strat === \"url\" &&\n            !isServer &&\n            typeof window !== \"undefined\") {\n            locale = extractLocaleFromUrl(window.location.href);\n        }\n        else if (TREE_SHAKE_GLOBAL_VARIABLE_STRATEGY_USED &&\n            strat === \"globalVariable\" &&\n            _locale !== undefined) {\n            locale = _locale;\n        }\n        else if (TREE_SHAKE_PREFERRED_LANGUAGE_STRATEGY_USED &&\n            strat === \"preferredLanguage\" &&\n            !isServer) {\n            locale = negotiatePreferredLanguageFromNavigator();\n        }\n        else if (TREE_SHAKE_LOCAL_STORAGE_STRATEGY_USED &&\n            strat === \"localStorage\" &&\n            !isServer) {\n            locale = localStorage.getItem(localStorageKey) ?? undefined;\n        }\n        // check if match, else continue loop\n        if (locale !== undefined) {\n            const asserted = assertIsLocale(locale);\n            if (!localeInitiallySet) {\n                _locale = asserted;\n                // https://github.com/opral/inlang-paraglide-js/issues/455\n                localeInitiallySet = true;\n                setLocale(asserted, { reload: false });\n            }\n            return asserted;\n        }\n    }\n    throw new Error(\"No locale found. Read the docs https://inlang.com/m/gerre34r/library-inlang-paraglideJs/errors#no-locale-found\");\n};\n/**\n * Negotiates a preferred language from navigator.languages.\n *\n * @returns {string|undefined} The negotiated preferred language.\n */\nfunction negotiatePreferredLanguageFromNavigator() {\n    if (!navigator?.languages?.length) {\n        return undefined;\n    }\n    const languages = navigator.languages.map((lang) => ({\n        fullTag: lang.toLowerCase(),\n        baseTag: lang.split(\"-\")[0]?.toLowerCase(),\n    }));\n    for (const lang of languages) {\n        if (isLocale(lang.fullTag)) {\n            return lang.fullTag;\n        }\n        else if (isLocale(lang.baseTag)) {\n            return lang.baseTag;\n        }\n    }\n    return undefined;\n}\n/**\n * Overwrite the \\`getLocale()\\` function.\n *\n * Use this function to overwrite how the locale is resolved. For example,\n * you can resolve the locale from the browser's preferred language,\n * a cookie, env variable, or a user's preference.\n *\n * @example\n *   overwriteGetLocale(() => {\n *     // resolve the locale from a cookie. fallback to the base locale.\n *     return Cookies.get('locale') ?? baseLocale\n *   }\n *\n * @type {(fn: () => Locale) => void}\n */\nexport const overwriteGetLocale = (fn) => {\n    getLocale = fn;\n};\n\n/**\n * Set the locale.\n *\n * Set locale reloads the site by default on the client. Reloading\n * can be disabled by passing \\`reload: false\\` as an option. If\n * reloading is disabled, you need to ensure that the UI is updated\n * to reflect the new locale.\n *\n * @example\n *   setLocale('en');\n *\n * @example\n *   setLocale('en', { reload: false });\n *\n * @type {(newLocale: Locale, options?: { reload?: boolean }) => void}\n */\nexport let setLocale = (newLocale, options) => {\n    const optionsWithDefaults = {\n        reload: true,\n        ...options,\n    };\n    // locale is already set\n    // https://github.com/opral/inlang-paraglide-js/issues/430\n    let currentLocale;\n    try {\n        currentLocale = getLocale();\n    }\n    catch {\n        // do nothing, no locale has been set yet.\n    }\n    /** @type {string | undefined} */\n    let newLocation = undefined;\n    for (const strat of strategy) {\n        if (TREE_SHAKE_GLOBAL_VARIABLE_STRATEGY_USED &&\n            strat === \"globalVariable\") {\n            // a default for a custom strategy to get started quickly\n            // is likely overwritten by `defineSetLocale()`\n            _locale = newLocale;\n        }\n        else if (TREE_SHAKE_COOKIE_STRATEGY_USED && strat === \"cookie\") {\n            if (isServer ||\n                typeof document === \"undefined\" ||\n                typeof window === \"undefined\") {\n                continue;\n            }\n            const domain = cookieDomain || window.location.hostname;\n            // set the cookie\n            document.cookie = `${cookieName}=${newLocale}; path=/; max-age=${cookieMaxAge}; domain=${domain}`;\n        }\n        else if (strat === \"baseLocale\") {\n            // nothing to be set here. baseLocale is only a fallback\n            continue;\n        }\n        else if (TREE_SHAKE_URL_STRATEGY_USED &&\n            strat === \"url\" &&\n            typeof window !== \"undefined\") {\n            // route to the new url\n            //\n            // this triggers a page reload but a user rarely\n            // switches locales, so this should be fine.\n            //\n            // if the behavior is not desired, the implementation\n            // can be overwritten by `defineSetLocale()` to avoid\n            // a full page reload.\n            newLocation = localizeUrl(window.location.href, {\n                locale: newLocale,\n            }).href;\n        }\n        else if (TREE_SHAKE_LOCAL_STORAGE_STRATEGY_USED &&\n            strat === \"localStorage\" &&\n            typeof window !== \"undefined\") {\n            // set the localStorage\n            localStorage.setItem(localStorageKey, newLocale);\n        }\n    }\n    if (!isServer &&\n        optionsWithDefaults.reload &&\n        window.location &&\n        newLocale !== currentLocale) {\n        if (newLocation) {\n            // reload the page by navigating to the new url\n            window.location.href = newLocation;\n        }\n        else {\n            // reload the page to reflect the new locale\n            window.location.reload();\n        }\n    }\n    return;\n};\n/**\n * Overwrite the \\`setLocale()\\` function.\n *\n * Use this function to overwrite how the locale is set. For example,\n * modify a cookie, env variable, or a user's preference.\n *\n * @example\n *   overwriteSetLocale((newLocale) => {\n *     // set the locale in a cookie\n *     return Cookies.set('locale', newLocale)\n *   });\n *\n * @param {(newLocale: Locale) => void} fn\n */\nexport const overwriteSetLocale = (fn) => {\n    setLocale = fn;\n};\n\n/**\n * The origin of the current URL.\n *\n * Defaults to \"http://y.com\" in non-browser environments. If this\n * behavior is not desired, the implementation can be overwritten\n * by `overwriteGetUrlOrigin()`.\n *\n * @type {() => string}\n */\nexport let getUrlOrigin = () => {\n    if (serverAsyncLocalStorage) {\n        return serverAsyncLocalStorage.getStore()?.origin ?? \"http://fallback.com\";\n    }\n    else if (typeof window !== \"undefined\") {\n        return window.location.origin;\n    }\n    return \"http://fallback.com\";\n};\n/**\n * Overwrite the getUrlOrigin function.\n *\n * Use this function in server environments to\n * define how the URL origin is resolved.\n *\n * @type {(fn: () => string) => void}\n */\nexport let overwriteGetUrlOrigin = (fn) => {\n    getUrlOrigin = fn;\n};\n\n/**\n * Check if something is an available locale.\n *\n * @example\n *   if (isLocale(params.locale)) {\n *     setLocale(params.locale);\n *   } else {\n *     setLocale('en');\n *   }\n *\n * @param {any} locale\n * @returns {locale is Locale}\n */\nexport function isLocale(locale) {\n    return !locale ? false : locales.includes(locale);\n}\n\n/**\n * Asserts that the input is a locale.\n *\n * @param {any} input - The input to check.\n * @returns {Locale} The input if it is a locale.\n * @throws {Error} If the input is not a locale.\n */\nexport function assertIsLocale(input) {\n    if (isLocale(input) === false) {\n        throw new Error(`Invalid locale: ${input}. Expected one of: ${locales.join(\", \")}`);\n    }\n    return input;\n}\n\n/**\n * Extracts a locale from a request.\n *\n * Use the function on the server to extract the locale\n * from a request.\n *\n * The function goes through the strategies in the order\n * they are defined. If a strategy returns an invalid locale,\n * it will fall back to the next strategy.\n *\n * @example\n *   const locale = extractLocaleFromRequest(request);\n *\n * @type {(request: Request) => Locale}\n */\nexport const extractLocaleFromRequest = (request) => {\n    /** @type {string|undefined} */\n    let locale;\n    for (const strat of strategy) {\n        if (TREE_SHAKE_COOKIE_STRATEGY_USED && strat === \"cookie\") {\n            locale = request.headers\n                .get(\"cookie\")\n                ?.split(\"; \")\n                .find((c) => c.startsWith(cookieName + \"=\"))\n                ?.split(\"=\")[1];\n        }\n        else if (TREE_SHAKE_URL_STRATEGY_USED && strat === \"url\") {\n            locale = extractLocaleFromUrl(request.url);\n        }\n        else if (TREE_SHAKE_PREFERRED_LANGUAGE_STRATEGY_USED &&\n            strat === \"preferredLanguage\") {\n            const acceptLanguageHeader = request.headers.get(\"accept-language\");\n            if (acceptLanguageHeader) {\n                locale = negotiatePreferredLanguageFromHeader(acceptLanguageHeader);\n            }\n        }\n        else if (strat === \"globalVariable\") {\n            locale = _locale;\n        }\n        else if (strat === \"baseLocale\") {\n            return baseLocale;\n        }\n        else if (strat === \"localStorage\") {\n            continue;\n        }\n        if (locale !== undefined) {\n            if (!isLocale(locale)) {\n                locale = undefined;\n            }\n            else {\n                return assertIsLocale(locale);\n            }\n        }\n    }\n    throw new Error(\"No locale found. There is an error in your strategy. Try adding 'baseLocale' as the very last strategy. Read more here https://inlang.com/m/gerre34r/library-inlang-paraglideJs/errors#no-locale-found\");\n};\n/**\n * Negotiates a preferred language from a header.\n *\n * @param {string} header - The header to negotiate from.\n * @returns {string|undefined} The negotiated preferred language.\n */\nfunction negotiatePreferredLanguageFromHeader(header) {\n    // Parse language preferences with their q-values and base language codes\n    const languages = header\n        .split(\",\")\n        .map((lang) => {\n        const [tag, q = \"1\"] = lang.trim().split(\";q=\");\n        // Get both the full tag and base language code\n        const baseTag = tag?.split(\"-\")[0]?.toLowerCase();\n        return {\n            fullTag: tag?.toLowerCase(),\n            baseTag,\n            q: Number(q),\n        };\n    })\n        .sort((a, b) => b.q - a.q);\n    for (const lang of languages) {\n        if (isLocale(lang.fullTag)) {\n            return lang.fullTag;\n        }\n        else if (isLocale(lang.baseTag)) {\n            return lang.baseTag;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Extracts a cookie from the document.\n *\n * Will return undefined if the docuement is not available or if the cookie is not set.\n * The `document` object is not available in server-side rendering, so this function should not be called in that context.\n *\n * @returns {string | undefined}\n */\nexport function extractLocaleFromCookie() {\n    if (typeof document === \"undefined\" || !document.cookie) {\n        return;\n    }\n    const match = document.cookie.match(new RegExp(`(^| )${cookieName}=([^;]+)`));\n    const locale = match?.[2];\n    if (isLocale(locale)) {\n        return locale;\n    }\n    return undefined;\n}\n\n/**\n * If extractLocaleFromUrl is called many times on the same page and the URL\n * hasn't changed, we don't need to recompute it every time which can get expensive.\n * We might use a LRU cache if needed, but for now storing only the last result is enough.\n * https://github.com/opral/monorepo/pull/3575#discussion_r2066731243\n */\n/** @type {string|undefined} */\nlet cachedUrl;\n/** @type {Locale|undefined} */\nlet cachedLocale;\n/**\n * Extracts the locale from a given URL using native URLPattern.\n *\n * @param {URL|string} url - The full URL from which to extract the locale.\n * @returns {Locale|undefined} The extracted locale, or undefined if no locale is found.\n */\nexport function extractLocaleFromUrl(url) {\n    const urlString = typeof url === \"string\" ? url : url.href;\n    if (cachedUrl === urlString) {\n        return cachedLocale;\n    }\n    let result;\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        result = defaultUrlPatternExtractLocale(url);\n    }\n    else {\n        const urlObj = typeof url === \"string\" ? new URL(url) : url;\n        // Iterate over URL patterns\n        for (const element of urlPatterns) {\n            for (const [locale, localizedPattern] of element.localized) {\n                const match = new URLPattern(localizedPattern, urlObj.href).exec(urlObj.href);\n                if (!match) {\n                    continue;\n                }\n                // Check if the locale is valid\n                if (assertIsLocale(locale)) {\n                    result = locale;\n                    break;\n                }\n            }\n            if (result)\n                break;\n        }\n    }\n    cachedUrl = urlString;\n    cachedLocale = result;\n    return result;\n}\n/**\n * https://github.com/opral/inlang-paraglide-js/issues/381\n *\n * @param {URL|string} url - The full URL from which to extract the locale.\n * @returns {Locale|undefined} The extracted locale, or undefined if no locale is found.\n */\nfunction defaultUrlPatternExtractLocale(url) {\n    const urlObj = new URL(url, \"http://dummy.com\");\n    const pathSegments = urlObj.pathname.split(\"/\").filter(Boolean);\n    if (pathSegments.length > 0) {\n        const potentialLocale = pathSegments[0];\n        if (isLocale(potentialLocale)) {\n            return potentialLocale;\n        }\n    }\n    // everything else has to be the base locale\n    return baseLocale;\n}\n\n/**\n * Lower-level URL localization function, primarily used in server contexts.\n *\n * This function is designed for server-side usage where you need precise control\n * over URL localization, such as in middleware or request handlers. It works with\n * URL objects and always returns absolute URLs.\n *\n * For client-side UI components, use `localizeHref()` instead, which provides\n * a more convenient API with relative paths and automatic locale detection.\n *\n * @example\n * ```typescript\n * // Server middleware example\n * app.use((req, res, next) => {\n *   const url = new URL(req.url, `${req.protocol}://${req.headers.host}`);\n *   const localized = localizeUrl(url, { locale: \"de\" });\n *\n *   if (localized.href !== url.href) {\n *     return res.redirect(localized.href);\n *   }\n *   next();\n * });\n * ```\n *\n * @example\n * ```typescript\n * // Using with URL patterns\n * const url = new URL(\"https://example.com/about\");\n * localizeUrl(url, { locale: \"de\" });\n * // => URL(\"https://example.com/de/about\")\n *\n * // Using with domain-based localization\n * const url = new URL(\"https://example.com/store\");\n * localizeUrl(url, { locale: \"de\" });\n * // => URL(\"https://de.example.com/store\")\n * ```\n *\n * @param {string | URL} url - The URL to localize. If string, must be absolute.\n * @param {Object} [options] - Options for localization\n * @param {string} [options.locale] - Target locale. If not provided, uses getLocale()\n * @returns {URL} The localized URL, always absolute\n */\nexport function localizeUrl(url, options) {\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        return localizeUrlDefaultPattern(url, options);\n    }\n    const targetLocale = options?.locale ?? getLocale();\n    const urlObj = typeof url === \"string\" ? new URL(url) : url;\n    // Iterate over URL patterns\n    for (const element of urlPatterns) {\n        // match localized patterns\n        for (const [, localizedPattern] of element.localized) {\n            const match = new URLPattern(localizedPattern, urlObj.href).exec(urlObj.href);\n            if (!match) {\n                continue;\n            }\n            const targetPattern = element.localized.find(([locale]) => locale === targetLocale)?.[1];\n            if (!targetPattern) {\n                continue;\n            }\n            const localizedUrl = fillPattern(targetPattern, aggregateGroups(match), urlObj.origin);\n            return fillMissingUrlParts(localizedUrl, match);\n        }\n        const unlocalizedMatch = new URLPattern(element.pattern, urlObj.href).exec(urlObj.href);\n        if (unlocalizedMatch) {\n            const targetPattern = element.localized.find(([locale]) => locale === targetLocale)?.[1];\n            if (targetPattern) {\n                const localizedUrl = fillPattern(targetPattern, aggregateGroups(unlocalizedMatch), urlObj.origin);\n                return fillMissingUrlParts(localizedUrl, unlocalizedMatch);\n            }\n        }\n    }\n    // If no match found, return the original URL\n    return urlObj;\n}\n/**\n * https://github.com/opral/inlang-paraglide-js/issues/381\n *\n * @param {string | URL} url\n * @param {Object} [options]\n * @param {string} [options.locale]\n * @returns {URL}\n */\nfunction localizeUrlDefaultPattern(url, options) {\n    const urlObj = typeof url === \"string\" ? new URL(url, getUrlOrigin()) : new URL(url);\n    const locale = options?.locale ?? getLocale();\n    const currentLocale = extractLocaleFromUrl(urlObj);\n    // If current locale matches target locale, no change needed\n    if (currentLocale === locale) {\n        return urlObj;\n    }\n    const pathSegments = urlObj.pathname.split(\"/\").filter(Boolean);\n    // If current path starts with a locale, remove it\n    if (pathSegments.length > 0 && isLocale(pathSegments[0])) {\n        pathSegments.shift();\n    }\n    // For base locale, don't add prefix\n    if (locale === baseLocale) {\n        urlObj.pathname = \"/\" + pathSegments.join(\"/\");\n    }\n    else {\n        // For other locales, add prefix\n        urlObj.pathname = \"/\" + locale + \"/\" + pathSegments.join(\"/\");\n    }\n    return urlObj;\n}\n/**\n * Low-level URL de-localization function, primarily used in server contexts.\n *\n * This function is designed for server-side usage where you need precise control\n * over URL de-localization, such as in middleware or request handlers. It works with\n * URL objects and always returns absolute URLs.\n *\n * For client-side UI components, use `deLocalizeHref()` instead, which provides\n * a more convenient API with relative paths.\n *\n * @example\n * ```typescript\n * // Server middleware example\n * app.use((req, res, next) => {\n *   const url = new URL(req.url, `${req.protocol}://${req.headers.host}`);\n *   const baseUrl = deLocalizeUrl(url);\n *\n *   // Store the base URL for later use\n *   req.baseUrl = baseUrl;\n *   next();\n * });\n * ```\n *\n * @example\n * ```typescript\n * // Using with URL patterns\n * const url = new URL(\"https://example.com/de/about\");\n * deLocalizeUrl(url); // => URL(\"https://example.com/about\")\n *\n * // Using with domain-based localization\n * const url = new URL(\"https://de.example.com/store\");\n * deLocalizeUrl(url); // => URL(\"https://example.com/store\")\n * ```\n *\n * @param {string | URL} url - The URL to de-localize. If string, must be absolute.\n * @returns {URL} The de-localized URL, always absolute\n */\nexport function deLocalizeUrl(url) {\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        return deLocalizeUrlDefaultPattern(url);\n    }\n    const urlObj = typeof url === \"string\" ? new URL(url) : url;\n    // Iterate over URL patterns\n    for (const element of urlPatterns) {\n        // Iterate over localized versions\n        for (const [, localizedPattern] of element.localized) {\n            const match = new URLPattern(localizedPattern, urlObj.href).exec(urlObj.href);\n            if (match) {\n                // Convert localized URL back to the base pattern\n                const groups = aggregateGroups(match);\n                const baseUrl = fillPattern(element.pattern, groups, urlObj.origin);\n                return fillMissingUrlParts(baseUrl, match);\n            }\n        }\n        // match unlocalized pattern\n        const unlocalizedMatch = new URLPattern(element.pattern, urlObj.href).exec(urlObj.href);\n        if (unlocalizedMatch) {\n            const baseUrl = fillPattern(element.pattern, aggregateGroups(unlocalizedMatch), urlObj.origin);\n            return fillMissingUrlParts(baseUrl, unlocalizedMatch);\n        }\n    }\n    // no match found return the original url\n    return urlObj;\n}\n/**\n * De-localizes a URL using the default pattern (/:locale/*)\n * @param {string|URL} url\n * @returns {URL}\n */\nfunction deLocalizeUrlDefaultPattern(url) {\n    const urlObj = typeof url === \"string\" ? new URL(url, getUrlOrigin()) : new URL(url);\n    const pathSegments = urlObj.pathname.split(\"/\").filter(Boolean);\n    // If first segment is a locale, remove it\n    if (pathSegments.length > 0 && isLocale(pathSegments[0])) {\n        urlObj.pathname = \"/\" + pathSegments.slice(1).join(\"/\");\n    }\n    return urlObj;\n}\n/**\n * Takes matches of implicit wildcards in the UrlPattern (when a part is missing\n * it is equal to '*') and adds them back to the result of fillPattern.\n *\n * At least protocol and hostname are required to create a valid URL inside fillPattern.\n *\n * @param {URL} url\n * @param {any} match\n * @returns {URL}\n */\nfunction fillMissingUrlParts(url, match) {\n    if (match.protocol.groups[\"0\"]) {\n        url.protocol = match.protocol.groups[\"0\"] ?? \"\";\n    }\n    if (match.hostname.groups[\"0\"]) {\n        url.hostname = match.hostname.groups[\"0\"] ?? \"\";\n    }\n    if (match.username.groups[\"0\"]) {\n        url.username = match.username.groups[\"0\"] ?? \"\";\n    }\n    if (match.password.groups[\"0\"]) {\n        url.password = match.password.groups[\"0\"] ?? \"\";\n    }\n    if (match.port.groups[\"0\"]) {\n        url.port = match.port.groups[\"0\"] ?? \"\";\n    }\n    if (match.pathname.groups[\"0\"]) {\n        url.pathname = match.pathname.groups[\"0\"] ?? \"\";\n    }\n    if (match.search.groups[\"0\"]) {\n        url.search = match.search.groups[\"0\"] ?? \"\";\n    }\n    if (match.hash.groups[\"0\"]) {\n        url.hash = match.hash.groups[\"0\"] ?? \"\";\n    }\n    return url;\n}\n/**\n * Fills a URL pattern with values for named groups, supporting all URLPattern-style modifiers.\n *\n * This function will eventually be replaced by https://github.com/whatwg/urlpattern/issues/73\n *\n * Matches:\n * - :name        -> Simple\n * - :name?       -> Optional\n * - :name+       -> One or more\n * - :name*       -> Zero or more\n * - :name(...)   -> Regex group\n * - {text}       -> Group delimiter\n * - {text}?      -> Optional group delimiter\n *\n * If the value is `null`, the segment is removed.\n *\n * @param {string} pattern - The URL pattern containing named groups.\n * @param {Record<string, string | null | undefined>} values - Object of values for named groups.\n * @param {string} origin - Base URL to use for URL construction.\n * @returns {URL} - The constructed URL with named groups filled.\n */\nfunction fillPattern(pattern, values, origin) {\n    // Pre-process the pattern to handle explicit port numbers\n    // This detects patterns like \"http://localhost:5173\" and protects the port number\n    // from being interpreted as a parameter\n    let processedPattern = pattern.replace(/(https?:\\/\\/[^:/]+):(\\d+)(\\/|$)/g, (_, protocol, port, slash) => {\n        // Replace \":5173\" with \"#PORT-5173#\" to protect it from parameter replacement\n        return `${protocol}#PORT-${port}#${slash}`;\n    });\n    // First, handle group delimiters with curly braces\n    let processedGroupDelimiters = processedPattern.replace(/\\{([^{}]*)\\}([?+*]?)/g, (_, content, modifier) => {\n        // For optional group delimiters\n        if (modifier === \"?\") {\n            // For optional groups, we'll include the content\n            return content;\n        }\n        // For non-optional group delimiters, always include the content\n        return content;\n    });\n    // Then handle named groups\n    let filled = processedGroupDelimiters.replace(/(\\/?):([a-zA-Z0-9_]+)(\\([^)]*\\))?([?+*]?)/g, (_, slash, name, __, modifier) => {\n        const value = values[name];\n        if (value === null) {\n            // If value is null, remove the entire segment including the preceding slash\n            return \"\";\n        }\n        if (modifier === \"?\") {\n            // Optional segment\n            return value !== undefined ? `${slash}${value}` : \"\";\n        }\n        if (modifier === \"+\" || modifier === \"*\") {\n            // Repeatable segments\n            if (value === undefined && modifier === \"+\") {\n                throw new Error(`Missing value for \"${name}\" (one or more required)`);\n            }\n            return value ? `${slash}${value}` : \"\";\n        }\n        // Simple named group (no modifier)\n        if (value === undefined) {\n            throw new Error(`Missing value for \"${name}\"`);\n        }\n        return `${slash}${value}`;\n    });\n    // Restore port numbers\n    filled = filled.replace(/#PORT-(\\d+)#/g, \":$1\");\n    return new URL(filled, origin);\n}\n/**\n * Aggregates named groups from various parts of the URLPattern match result.\n *\n *\n * @type {(match: any) => Record<string, string | null | undefined>}\n */\nexport function aggregateGroups(match) {\n    return {\n        ...match.hash.groups,\n        ...match.hostname.groups,\n        ...match.password.groups,\n        ...match.pathname.groups,\n        ...match.port.groups,\n        ...match.protocol.groups,\n        ...match.search.groups,\n        ...match.username.groups,\n    };\n}\n\n/**\n * High-level URL localization function optimized for client-side UI usage.\n *\n * This is a convenience wrapper around `localizeUrl()` that provides features\n * needed in UI:\n *\n * - Accepts relative paths (e.g., \"/about\")\n * - Returns relative paths when possible\n * - Automatically detects current locale if not specified\n * - Handles string input/output instead of URL objects\n *\n * @example\n * ```typescript\n * // In a React/Vue/Svelte component\n * const NavLink = ({ href }) => {\n *   // Automatically uses current locale, keeps path relative\n *   return <a href={localizeHref(href)}>...</a>;\n * };\n *\n * // Examples:\n * localizeHref(\"/about\")\n * // => \"/de/about\" (if current locale is \"de\")\n * localizeHref(\"/store\", { locale: \"fr\" })\n * // => \"/fr/store\" (explicit locale)\n *\n * // Cross-origin links remain absolute\n * localizeHref(\"https://other-site.com/about\")\n * // => \"https://other-site.com/de/about\"\n * ```\n *\n * For server-side URL localization (e.g., in middleware), use `localizeUrl()`\n * which provides more precise control over URL handling.\n *\n * @param {string} href - The href to localize (can be relative or absolute)\n * @param {Object} [options] - Options for localization\n * @param {string} [options.locale] - Target locale. If not provided, uses `getLocale()`\n * @returns {string} The localized href, relative if input was relative\n */\nexport function localizeHref(href, options) {\n    const currentLocale = getLocale();\n    const locale = options?.locale ?? currentLocale;\n    const url = new URL(href, getUrlOrigin());\n    const localized = localizeUrl(url, { locale });\n    // if the origin is identical and the href is relative,\n    // return the relative path\n    if (href.startsWith(\"/\") && url.origin === localized.origin) {\n        // check for cross origin localization in which case an absolute URL must be returned.\n        if (locale !== currentLocale) {\n            const localizedCurrentLocale = localizeUrl(url, {\n                locale: currentLocale,\n            });\n            if (localizedCurrentLocale.origin !== localized.origin) {\n                return localized.href;\n            }\n        }\n        return localized.pathname + localized.search + localized.hash;\n    }\n    return localized.href;\n}\n/**\n * High-level URL de-localization function optimized for client-side UI usage.\n *\n * This is a convenience wrapper around `deLocalizeUrl()` that provides features\n * needed in the UI:\n *\n * - Accepts relative paths (e.g., \"/de/about\")\n * - Returns relative paths when possible\n * - Handles string input/output instead of URL objects\n *\n * @example\n * ```typescript\n * // In a React/Vue/Svelte component\n * const LocaleSwitcher = ({ href }) => {\n *   // Remove locale prefix before switching\n *   const baseHref = deLocalizeHref(href);\n *   return locales.map(locale =>\n *     <a href={localizeHref(baseHref, { locale })}>\n *       Switch to {locale}\n *     </a>\n *   );\n * };\n *\n * // Examples:\n * deLocalizeHref(\"/de/about\")  // => \"/about\"\n * deLocalizeHref(\"/fr/store\")  // => \"/store\"\n *\n * // Cross-origin links remain absolute\n * deLocalizeHref(\"https://example.com/de/about\")\n * // => \"https://example.com/about\"\n * ```\n *\n * For server-side URL de-localization (e.g., in middleware), use `deLocalizeUrl()`\n * which provides more precise control over URL handling.\n *\n * @param {string} href - The href to de-localize (can be relative or absolute)\n * @returns {string} The de-localized href, relative if input was relative\n * @see deLocalizeUrl - For low-level URL de-localization in server contexts\n */\nexport function deLocalizeHref(href) {\n    const url = new URL(href, getUrlOrigin());\n    const deLocalized = deLocalizeUrl(url);\n    // If the origin is identical and the href is relative,\n    // return the relative path instead of the full URL.\n    if (href.startsWith(\"/\") && url.origin === deLocalized.origin) {\n        return deLocalized.pathname + deLocalized.search + deLocalized.hash;\n    }\n    return deLocalized.href;\n}\n\n/**\n * @param {string} safeModuleId\n * @param {Locale} locale\n */\nexport function trackMessageCall(safeModuleId, locale) {\n    if (isServer === false)\n        return;\n    const store = serverAsyncLocalStorage?.getStore();\n    if (store) {\n        store.messageCalls?.add(`${safeModuleId}:${locale}`);\n    }\n}\n\n/**\n * Generates a list of localized URLs for all provided URLs.\n *\n * This is useful for SSG (Static Site Generation) and sitemap generation.\n * NextJS and other frameworks use this function for SSG.\n *\n * @example\n * ```typescript\n * const urls = generateStaticLocalizedUrls([\n *   \"https://example.com/about\",\n *   \"https://example.com/blog\",\n * ]);\n * urls[0].href // => \"https://example.com/about\"\n * urls[1].href // => \"https://example.com/blog\"\n * urls[2].href // => \"https://example.com/de/about\"\n * urls[3].href // => \"https://example.com/de/blog\"\n * ...\n * ```\n *\n * @param {(string | URL)[]} urls - List of URLs to generate localized versions for. Can be absolute URLs or paths.\n * @returns {URL[]} List of localized URLs as URL objects\n */\nexport function generateStaticLocalizedUrls(urls) {\n    const localizedUrls = new Set();\n    // For default URL pattern, we can optimize the generation\n    if (TREE_SHAKE_DEFAULT_URL_PATTERN_USED) {\n        for (const urlInput of urls) {\n            const url = urlInput instanceof URL\n                ? urlInput\n                : new URL(urlInput, \"http://localhost\");\n            // Base locale doesn't get a prefix\n            localizedUrls.add(url);\n            // Other locales get their code as prefix\n            for (const locale of locales) {\n                if (locale !== baseLocale) {\n                    const localizedPath = `/${locale}${url.pathname}${url.search}${url.hash}`;\n                    const localizedUrl = new URL(localizedPath, url.origin);\n                    localizedUrls.add(localizedUrl);\n                }\n            }\n        }\n        return Array.from(localizedUrls);\n    }\n    // For custom URL patterns, we need to use localizeUrl for each URL and locale\n    for (const urlInput of urls) {\n        const url = urlInput instanceof URL\n            ? urlInput\n            : new URL(urlInput, \"http://localhost\");\n        // Try each URL pattern to find one that matches\n        let patternFound = false;\n        for (const pattern of urlPatterns) {\n            try {\n                // Try to match the unlocalized pattern\n                const unlocalizedMatch = new URLPattern(pattern.pattern, url.href).exec(url.href);\n                if (!unlocalizedMatch)\n                    continue;\n                patternFound = true;\n                // Track unique localized URLs to avoid duplicates when patterns are the same\n                const seenUrls = new Set();\n                // Generate localized URL for each locale\n                for (const [locale] of pattern.localized) {\n                    try {\n                        const localizedUrl = localizeUrl(url, { locale });\n                        const urlString = localizedUrl.href;\n                        // Only add if we haven't seen this exact URL before\n                        if (!seenUrls.has(urlString)) {\n                            seenUrls.add(urlString);\n                            localizedUrls.add(localizedUrl);\n                        }\n                    }\n                    catch {\n                        // Skip if localization fails for this locale\n                        continue;\n                    }\n                }\n                break;\n            }\n            catch {\n                // Skip if pattern matching fails\n                continue;\n            }\n        }\n        // If no pattern matched, use the URL as is\n        if (!patternFound) {\n            localizedUrls.add(url);\n        }\n    }\n    return Array.from(localizedUrls);\n}\n\n// ------ TYPES ------\n\n/**\n * A locale that is available in the project.\n *\n * @example\n *   setLocale(request.locale as Locale)\n *\n * @typedef {(typeof locales)[number]} Locale\n */\n\n"],"names":["if_block","node","fn","elseif","hydrating","hydrate_next","branches","BranchManager","flags","EFFECT_TRANSPARENT","update_branch","key","data","read_hydration_instruction","hydrated_key","HYDRATION_START","HYDRATION_START_ELSE","anchor","skip_nodes","set_hydrate_node","set_hydrating","block","has_branch","is_bound_this","bound_value","element_or_component","STATE_SYMBOL","bind_this","update","get_value","get_parts","effect","old_parts","parts","render_effect","untrack","queue_micro_task","is_store_binding","capture_store_binding","previous_is_store_binding","rest_props_handler","target","rest_props","props","exclude","name","prop","fallback","runes","legacy_mode_flag","PROPS_IS_RUNES","bindable","PROPS_IS_BINDABLE","lazy","PROPS_IS_LAZY_INITIAL","fallback_value","fallback_dirty","get_fallback","setter","is_entry_props","LEGACY_PROPS","_a","get_descriptor","v","initial_value","is_store_sub","e.props_invalid_value","getter","value","PROPS_IS_UPDATED","legacy_parent","mutation","overridden","d","PROPS_IS_IMMUTABLE","derived","derived_safe_equal","get","parent_effect","active_effect","new_value","proxy","set","is_destroying_effect","DESTROYED","baseLocale","locales","cookieName","cookieMaxAge","strategy","localeInitiallySet","getLocale","locale","strat","extractLocaleFromCookie","negotiatePreferredLanguageFromNavigator","asserted","assertIsLocale","setLocale","languages","lang","isLocale","newLocale","options","optionsWithDefaults","currentLocale","domain","getUrlOrigin","input","match","deLocalizeUrl","url","deLocalizeUrlDefaultPattern","urlObj","pathSegments"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}